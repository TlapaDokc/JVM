# JVM

## Выполнение кода на JVM

Для того, чтобы получить код, работающий в JVM, необходимо выполнить 3 этапа:

* Загрузка байт-кода и создание экземпляра класса Class.
Для этого существуют отдельные класс-загрузчики(СlassLoader).
* Связывание или линковка
После загрузки класса начинается процесс линковки, на котором байт-код разбирается и проверяется.
* Ициализация полученного объекта Class
На последнем этапе класс, который мы создали, инициализируется, и JVM может начинать его исполнение.

Основываясь на информации выше, рассмотрим, как происходит подготовка и исполнение кода на простом примере:

   ```
    public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                                         
        Object o = new Object();           
        Integer ii = 2;                               
        printAll(o, i, ii);                             
        System.out.println("finished"); 
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   
        System.out.println(o.toString() + i + ii); 
    }
}
```

## Загрузчики классов и их иерархия

Грубо говоря, чтобы попасть на JVM, наш класс ```JvmComprehension``` должен быть загружен. Этим занимаются загрузчики класса(СlassLoader) — это специальные классы, которые являются частью JVM. Они загружают классы в память и делают их доступными для выполнения. 
ClassLoader делятся на три класса, а процесс загрузки классов происходит по иерархии:
 
* В первую очередь мы запрашиваем поиск в кэше System Class Loader (кэш системного загрузчика содержит классы, которые уже были им загружены);
* Если класс не был найден в кэше системного загрузчика, мы смотрим кэш Extension class loader;
* Если класс не найден в кэше загрузчика расширений, класс запрашивается у загрузчика Bootstrap.
* Если класс не найден в кэше Bootstrap, он пытается загрузить этот класс. Если Bootstrap не смог загрузить класс, он делегирует загрузку класса загрузчику расширений. Если на этот момент класс будет загружен, он остается в кэше у Extension classloader, а загрузка класса является завершенной.

После загрузки класса начинается процесс линковки, который в свою очередь происходит в 3 шага:

1. verification или проверка байт-кода: проверяется корректность инструкций, возможность переполнения стека на данном участке кода, совместимость типов переменных; проверка происходит один раз для каждого класса;

2. preparation или подготовка: на данном этапе в соответствии со спецификацией выделяется память под статические поля и происходит их инициализация;

3. resolution или разрешение: разрешение символьных ссылок (когда в байт-коде мы открываем файлы с расширением .class, мы видим числовые значения вместо символьных ссылок).
Инициализация полученного объекта Class
На последнем этапе класс, который мы создали, инициализируется в области памяти Metaspace, и JVM может начинать его исполнение.

## Исполнение байт-кода на JVM

Для исполнения байт-кода, JVM может его интерпретировать. Интерпретация — довольно медленный процесс. В процессе интерпретации, интерпретатор “бежит” построчно по класс-файлу и переводит его в команды, которые понятны JVM.
Также JVM может его транслировать, т.е. скомпилировать в машинный код, который будет исполняться непосредственно на CPU.
Команды, которые исполняются часто, не будут интерпретироваться, а сразу будут транслироваться.

Рассмотрим организацию памяти в JVM при исполнении нашего  кода:
```
    public class JvmComprehension {

    public static void main(String[] args) {        
        int i = 1;                                                          
        Object o = new Object();           
        Integer ii = 2;                               
        printAll(o, i, ii);                             
        System.out.println("finished"); 
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   
        System.out.println(o.toString() + i + ii); 
    }
}
```
У нас есть класс ```JvmComprehension```,в котором есть метод ```main``` состоящий из:
* примитивной переменной ```int i = 1```
* ссылочные переменные ```Object o = new Object()``` и ```Integer ii = 2```
* метод ```printAll(o, i, ii)``` и ```System.out.println("finished")```

В момент вызова метода ```main```, на вершине стека создаётся фрейм (область памяти для выполнения метода) в стеке(Stack). Стек нужен для того, чтобы хранить методы. Переменные в стеке существуют до тех пор, пока выполняется метод в котором они были созданы.
Когда вызывается любой метод в Java, создается фрейм или область памяти в стеке, и метод кладется на его вершину. Когда метод завершает выполнение, он удаляется из памяти, тем самым освобождая память для следующих методов.
Таким образом, внутри фрейма метода main, будут помещены переменные для выполнения этого метода:
 ```
int i = 1;                                                        
Object o = new Object();           
Integer ii = 2;
```
Переменные примитивного типа инициализируются и будут храниться в фрейме в явном виде, для ссылочных переменных будут храниться ссылка(адрес), а сам объекты будут инициализированны и храниться в куче (Heap).
Ещё одна область памяти в Java — Heap или куча. Она используется для хранения объектов и классов. Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке.
При выполнении метода ```printAll(o, i, ii)```, JVM создаст новый фрейм в стеке, передаст управление этому методу и поместит туда необходимые переменные, ссылочные объекты также будут хранится в куче, а в фрейме ссылки на объекты:
```
Object o;
int i;
Integer ii;
Integer uselessVar = 700;
```
Для выполнения метода ```printAll(o, i, ii)```, необходимо выполнить метод ```println(o.toString() + i + ii)```, результат которого инициализируется в куче, фреймы выделенные для этих методов удалится из стека, а управление передастся методу ```main```.
В свою очередь, метод ```main``` передаст управление методу ```println()```, после завершения которого метод ```main``` удалится из очереди.

## Garbage collector

В куче работает Garbage collector — программа, которая избавляется от объектов, к которым невозможно получить доступ.
Разные JVM могут иметь различные алгоритмы сборки мусора, также существуют разные сборщики мусора.
Основной принцип работы GC:
Недостижимые объекты удаляются;
Достижимые объекты группируются по времени жизни (поколения).
Чем дольше объект живёт, тем реже проверяют, нужно ли его удалить.

Куча разбита на 2 области: New generation и Old generation. 
New generation (младшее поколение) включает в себя 3 региона: Eden, Survivor 0 и Survivor 1. 
Old generation включает в себя регион Tenured.
Что происходит, когда мы создаем в Java объект?
В первую очередь объект попадает в Eden. Если мы создали уже много объектов и в Eden уже нет места, срабатывает сборщик мусора и освобождает память. Это, так называемая, малая сборка мусора — на первом проходе он очищает область Eden и кладёт “выжившие” объекты в регион Survivor 0. Таким образом регион Eden полностью высвобождается.
Если произошло так, что область Eden снова была заполнена, garbage collector начинает работу с областью Eden и областью Survivor 0, которая занята на данный момент. После очищения выжившие объекты попадут в другой регион — Survivor 1, а два остальных останутся чистыми. При последующей сборке мусора в качестве региона назначения опять будет выбран Survivor 0. Именно поэтому важно, чтобы один из регионов Survivor всегда был пустым.
JVM следит за объектами, которые постоянно копируются и перемещаются из одного региона в другой. И для того, чтобы оптимизировать данный механизм, после определённого порога сборщик мусора перемещает такие объекты в регион Tenured.
Когда в Tenured места для новых объектов не хватает, происходит полная сборка мусора — Mark-Sweep-Compact.
Во время этого механизма определяется, какие объекты больше не используются, регион очищается от этих объектов, и область памяти Tenured дефрагментируется, т.е. последовательно заполняется нужными объектами.

Таким образом, происходят базовые принципы и этапы выполнения кода на JVM, компиляция, организация памяти, а также принцип работы сборщика мусора.